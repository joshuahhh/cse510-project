<!DOCTYPE html>

<head>
  <style>
    #live_debugger {
      width: 100%;
      margin: 5px
    }
  </style>
  <script defer type="module">
    const split_view = ({ parent = document.createElement('div'), left = parent.childNodes, right = [], /*top, bottom*/ initial_width = '75%' } = {}) => {
      // TODO add top/bottom support using https://github.com/1milligram/html-dom/blob/master/public/demo/create-resizable-split-views/direction.html

      const left_nodes = left.nodeName !== undefined ? [left] : [...left]  // NOTE preserve pointers before mutating below
      const right_nodes = right.nodeName !== undefined ? [right] : [...right]
      const target = parent

      const style_text = `
.container {
display: flex;

/* Misc */

/*border: 1px solid #cbd5e0;
height: 16rem;
width: 100%;*/

}
.container__left {
  /* Initially, the left takes 3/4 width */
  /*width: 75%;*/
  
  /* Misc */
  display: flex;
}
.split-view-resizer {
  background-color: #cbd5e0;
  cursor: ew-resize;
  /*height: 100%;*/
  width: 2px;
}
.container__right {
/* Take the remaining width */
flex: 1;

/* Misc */
display: flex;
}`
      const style = document.createElement('style')
      style.classList.add("split-view-style")
      style.innerHTML = style_text


      target.classList.add('container')

      const container = document.createElement('div')
      container.classList.add("container__left")

      container.style.width = initial_width

      target.prepend(container)
      left_nodes.map(c => container.appendChild(c))

      const resizer = html`<div class="split-view-resizer">`
      target.appendChild(resizer)

      const panel = document.createElement('div')
      panel.classList.add("container__right")
      right_nodes.map(c => panel.appendChild(c))

      target.appendChild(panel)

      const leftSide = container
      const rightSide = panel

      // The current position of mouse
      let x = 0;
      let y = 0;
      let leftWidth = 0;

      // Handle the mousedown event
      // that's triggered when user drags the resizer
      const mouseDownHandler = function (e) {
        // Get the current mouse position
        x = e.clientX;
        y = e.clientY;
        leftWidth = leftSide.getBoundingClientRect().width;

        // Attach the listeners to `document`
        document.addEventListener('mousemove', mouseMoveHandler);
        document.addEventListener('mouseup', mouseUpHandler);
      };

      const mouseMoveHandler = function (e) {
        // How far the mouse has been moved
        const dx = e.clientX - x;
        const dy = e.clientY - y;

        const newLeftWidth = ((leftWidth + dx) * 100) / resizer.parentNode.getBoundingClientRect().width;
        leftSide.style.width = `${newLeftWidth}%`;

        resizer.style.cursor = 'col-resize';
        document.body.style.cursor = 'col-resize';

        leftSide.style.userSelect = 'none';
        leftSide.style.pointerEvents = 'none';

        rightSide.style.userSelect = 'none';
        rightSide.style.pointerEvents = 'none';
      };

      const mouseUpHandler = function () {
        resizer.style.removeProperty('cursor');
        document.body.style.removeProperty('cursor');

        leftSide.style.removeProperty('user-select');
        leftSide.style.removeProperty('pointer-events');

        rightSide.style.removeProperty('user-select');
        rightSide.style.removeProperty('pointer-events');

        // Remove the handlers of `mousemove` and `mouseup`
        document.removeEventListener('mousemove', mouseMoveHandler);
        document.removeEventListener('mouseup', mouseUpHandler);
      };

      // Attach the handler
      resizer.addEventListener('mousedown', mouseDownHandler);

      parent.prepend(style)
      return parent
    }
    
    
    const debugger_interface = async ({ set_state }) => {

      const skypack = (library) => import(`https://cdn.skypack.dev/${library}?min`)
      const html = (await skypack("htl")).html
      const Inspector = (await skypack("@observablehq/inspector@3.2.2/dist/inspector.js")).default.Inspector
      const inspector_style = (await (await fetch('https://raw.githubusercontent.com/observablehq/inspector/main/src/style.css')).text())
      function inspect(value) {
        const root = document.createElement("DIV");
        new Inspector(root).fulfilled(value);
        const element = root.firstChild;
        element.remove();
        element.value = value; // for viewof
        return element;
      }

      const compute_output = (input, text) => {
        let out = undefined
        try {
          out = new Function('return ' + text)()(input)
        } catch (e) {
          //console.log('error object keys: ', Object.getOwnPropertyNames(e))
          // syntax errors work like this in Firefox, not sure about Chrome or other errors
          return new Error(`[line ${e.lineNumber - 2}, column ${e.columnNumber}] ${e.message} ${e.message.includes("got '}'") ? '(unterminated expression)' : ''}`)
        }
        return out
      }
      const output = (inputs, transformation = x => x) => {
        if (!Array.isArray(inputs)) {
          inputs = [inputs]
        }
        if (inputs.some(input => !(input instanceof Element)))
          throw new Error('Argument should be an HTML input (must support .value and .addEventListener).')
        const ui = html`<span class="output">`  // HACK the content has to live somewhere for replaceChildren to work...
        const get_value = () => transformation(...inputs.map(input => input.value))
        let cache = get_value()
        ui.replaceChildren(...[cache])
        inputs.map((input, _) =>
          input.addEventListener('input', e => {
            cache = get_value()
            ui.replaceChildren(...[cache])
            ui.dispatchEvent(new Event('input'))
          }))
        Object.defineProperty(ui, 'value', {
          get: () => cache,
          set: newVal => undefined  // TODO maybe these can be used as primary sources/value stores as well?
        })
        return ui
      }
      const button = (text, cb) => {
        const out = html`<button>${text}</button>`
        out.onclick = cb
        return out
      }
      return async ({ current_input, callback, interactive = true, active = true, code }) => {
        //editor.setOption("readonly", !interactive)
        console.log('building the editor')
        const editor = await (async () => {
          const { EditorState, EditorView, basicSetup } = await skypack('@codemirror/next/basic-setup')
          const { javascript } = await skypack('@codemirror/next/lang-javascript')

          const updateViewOf = EditorView.updateListener.of((update) => {
            // HACKs here to report state and maintain our state
            const newCode = update.state.doc.toString()
            const { dom } = update.view
            dom.value = newCode
            if (newCode == code) return
            set_state({ code: newCode })
            code = newCode
            dom.dispatchEvent(new CustomEvent('input'))
          })

          const view = new EditorView({
            state: EditorState.create({
              doc: code,
              extensions: [basicSetup, javascript(), updateViewOf, ...(interactive && active ? [] : [EditorView.editable.of(false)])]  // disable editing if not interactive
            })
          })
          view.dom.value = code  // HACK because the value isn't inited
          return view.dom
        })()
        console.log(current_input, callback, interactive, active)
        if (!interactive) {
          callback(compute_output(JSON.parse(current_input), editor.value))
        }
        console.log('rendering component', editor)
        const output_temp = output(editor, q => {
          try {
            return compute_output(JSON.parse(current_input), q)
          } catch (e) {
            console.log(e)
            return e
          }
        })
        console.log('computed output, now returning html')
        return html`
  <div id="livedebug">
  Input: <div id="input">${inspect(JSON.parse(current_input))}</div>

  <div id="editor">${editor}</div>

  Output:
  <div id="output">
  ${output(output_temp, q => q instanceof Error ? q : inspect(q))}
  </div>

  <div>
  ${output(output_temp, q =>
          q instanceof Error ? "(Can't send bad output.)"
            : !active || !interactive ? '(viewing mode)'
              : button("Send response", async () => { callback(q); await set_state({ active: false }) }))}

  ${!interactive ? button("Activate breakpoint", async () => await set_state({ interactive: true }))
            : button("Deactivate breakpoint", async () => await set_state({ interactive: false }))}
  </div>
  </div>
  <style>
  #livedebug {
    border: 1px solid black
  }
  #editor {
    width: 100%
  }
  ${inspector_style}
  .observablehq--inspect {
    white-space: pre-wrap
  }
  </style>
  `
      }
    }

    // (in library)
    const skypack = (library) => import(`https://cdn.skypack.dev/${library}?min`)

    console.log('getting htl')
    const html = (await skypack("htl")).html
    console.log('got it')



    const liveDebugger = async (id, current_input, config) => {
      current_input = JSON.stringify(current_input)
      const storage_name = 'live_debugger_config'

      config = config || JSON.parse(window.localStorage.getItem(storage_name) || "false") || {
        interactive: true,
        code: `function (input) {\n  return input\n}`
      }
      // Mark the component as active
      config.active = true

      const update_local_copy = config =>
        fetch(`http://localhost:3000/set?id=${id}&config=${JSON.stringify(config)}`)

      let debugger_div = document.querySelector('#live_debugger')
      if (!debugger_div) {
        debugger_div = html`<div id="live_debugger"></div>`
        split_view({ parent: document.body, left: document.body.childNodes, right: debugger_div })
        //document.body.appendChild(debugger_div)
      }

      let resolve = undefined
      const p = new Promise(r => resolve = r)

      const set_state = async update => {
        console.log('applying update', update)
        config = { ...config, ...update }
        window.localStorage.setItem(storage_name, JSON.stringify(config))
        console.log('new state', config)

        if (!update.code) // don't rerender on code changes (or on output)
          render_into_div(debugger_div)
        //debugger_div.replaceChildren(await render({ callback: o => resolve(o), current_input, ...config }))

        update_local_copy(config)
      }

      console.log('getting debugger interface')
      const render = await debugger_interface({ set_state, code: config.code, interactive: config.interactive })
      const render_into_div = async div => debugger_div.replaceChildren(await render({ callback: o => resolve(o), current_input, ...config }))

      console.log('initially rendering debugger')
      render_into_div(debugger_div)
      //debugger_div.replaceChildren(await render({ callback: o => resolve(o), current_input, ...config }))
      console.log('rendered')
      return p
    }



    const board = () => {
      // Define the board
      const num_rows_cols = 5
      const protag_img_src = "https://images-wixmp-ed30a86b8c4ca887773594c2.wixmp.com/f/77a638c2-9d34-4f8d-9aef-edb8d196b304/d6ebtax-b9380050-b687-43dd-a42b-f74c3dd57307.png/v1/fill/w_1024,h_1303,strp/bowser_png_by_brokenheartdesignz_d6ebtax-fullview.png?token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ1cm46YXBwOjdlMGQxODg5ODIyNjQzNzNhNWYwZDQxNWVhMGQyNmUwIiwiaXNzIjoidXJuOmFwcDo3ZTBkMTg4OTgyMjY0MzczYTVmMGQ0MTVlYTBkMjZlMCIsIm9iaiI6W1t7ImhlaWdodCI6Ijw9MTMwMyIsInBhdGgiOiJcL2ZcLzc3YTYzOGMyLTlkMzQtNGY4ZC05YWVmLWVkYjhkMTk2YjMwNFwvZDZlYnRheC1iOTM4MDA1MC1iNjg3LTQzZGQtYTQyYi1mNzRjM2RkNTczMDcucG5nIiwid2lkdGgiOiI8PTEwMjQifV1dLCJhdWQiOlsidXJuOnNlcnZpY2U6aW1hZ2Uub3BlcmF0aW9ucyJdfQ.Bw_-_BSZzKDu771C-F92ZtRMDCf_Su_x96sXfkVA3Zw"
      const enemy_img_src = "https://pngimg.com/uploads/mario/mario_PNG57.png"
      function getWidth() {
        return Math.max(
          document.body.scrollWidth,
          document.documentElement.scrollWidth,
          document.body.offsetWidth,
          document.documentElement.offsetWidth,
          document.documentElement.clientWidth
        );
      }
      const style = () => {
        const size = `${Math.min(100, getWidth() / num_rows_cols)}px`;
        return html`<style>
#game-board {
  display: grid;
  grid-template-columns: ${(size + " ").repeat(num_rows_cols)};
  grid-template-rows: ${(size + " ").repeat(num_rows_cols)};
  justify-content: center;
  padding: 20px;
}
#game-board div {
  background: #d9d9d9;
  border: 2px solid black;
  width: ${size};
  height: ${size};
}
#game-board div.user-next {
  background: blue;
}
#game-board div.correct-next {
  background: green;
}
#game-board img {
  height: ${size};
  width: ${size};
  cursor: grab;
  position: absolute; /* layer images */
  object-fit: scale-down; /* fit in cell */
}
textarea {
  font-family: monospace !important;
}
</style>`;
      }
      document.body.appendChild(style())

      const board = html`<div id="game-board" tabindex="0">${Array(
        num_rows_cols ** 2
      )
        .fill()
        .map((_, i) => html`<div data-id='${i}'></div>`)}</div>`

      // Create Bowser (as an HTML image)
      let protag = html`<img id="protag" src="${protag_img_src}" />`;
      let protag_pos = Math.floor(Math.random() * num_rows_cols ** 2);
      console.log(board.outerHTML)
      board.querySelector(`div[data-id="${protag_pos}"]`).appendChild(protag);

      // Create Mario (as an HTML image)
      let enemy = html`<img id="enemy" src="${enemy_img_src}" />`;
      let enemy_pos = protag_pos;
      while (enemy_pos === protag_pos) {
        enemy_pos = Math.floor(Math.random() * num_rows_cols ** 2);
      }
      board.querySelector(`div[data-id="${enemy_pos}"]`).appendChild(enemy);

      const divmod = (n) => [n % num_rows_cols, Math.floor(n / num_rows_cols)];

      // Handle user input
      // EXPERIMENT NOTE they have to figure out that this should be async
      async function applyUserInput() {
        let [protag_y, protag_x] = divmod(+protag.parentElement.dataset.id);
        let [enemy_y, enemy_x] = divmod(+enemy.parentElement.dataset.id);
        // Define Bowser's next move
        let [user_next_y, user_next_x] = await liveDebugger('id1', {
          protag_x,
          protag_y,
          enemy_x,
          enemy_y,
          num_rows_cols
        })/*[1, 1]/*eval(`(${my_code})`)(
          protag_x,
          protag_y,
          enemy_x,
          enemy_y,
          num_rows_cols
        );*/
        let user_next = user_next_y * num_rows_cols + user_next_x;
        board.querySelector("div.user-next")?.classList.remove("user-next");
        board
          .querySelector(`div[data-id="${user_next}"]`)
          ?.classList.add("user-next");
      }

      // Detecting arrow key presses and moving protagonist
      board.addEventListener("keydown", async (e) => {
        let [protag_x, protag_y] = divmod(+protag.parentElement.dataset.id);
        switch (e.key) {
          case "ArrowLeft":
            protag_x -= 1;
            break;
          case "ArrowUp":
            protag_y -= 1;
            break;
          case "ArrowRight":
            protag_x += 1;
            break;
          case "ArrowDown":
            protag_y += 1;
            break;
          default:
            return;
        }
        e.preventDefault();

        // ignore input out of bounds
        if (
          protag_x < 0 ||
          protag_y < 0 ||
          protag_x >= num_rows_cols ||
          protag_y >= num_rows_cols
        ) {
          return;
        }
        let protag_pos = protag_y * num_rows_cols + protag_x;
        board.querySelector(`div[data-id="${protag_pos}"]`).appendChild(protag);
        applyUserInput();
      });

      //applyUserInput();

      return Object.assign(board, { applyUserInput });
    }


    const handlers = board => {
      function does_intersect(el, mouse) {
        return (
          mouse.clientX >= el.left &&
          mouse.clientX <= el.right &&
          mouse.clientY >= el.top &&
          mouse.clientY <= el.bottom
        );
      }

      // let board = document.querySelector("#game-board");
      let protag = board.querySelector("#protag");
      let enemy = board.querySelector("#enemy");
      let is_dragged = false;
      let dragged_elem = null;

      // Disable image preview drag
      protag.ondragstart = function () {
        return false;
      };
      enemy.ondragstart = function () {
        return false;
      };

      // Add image drag event listeners
      [].slice.call(board.children).forEach((el) => {
        el.addEventListener("mouseenter", function (event) {
          if (is_dragged) {
            el.appendChild(dragged_elem);
            board.applyUserInput();
          }
        });
      });

      // Add global image click event listeners
      document.addEventListener("mousedown", function (event) {
        if (does_intersect(protag.getBoundingClientRect(), event)) {
          dragged_elem = protag;
          is_dragged = true;
        } else if (does_intersect(enemy.getBoundingClientRect(), event)) {
          dragged_elem = enemy;
          is_dragged = true;
        }
      });
      document.addEventListener("mouseup", function () {
        is_dragged = false;
      });
    }
    
    const b = board()
    document.body.appendChild(b)
    handlers(b)
    b.applyUserInput()

    // let input = { a: 42 }
    // console.log('calling debugger')
    // while (true) {
    //   const output = await liveDebugger('id1', input)
    //   console.log(output)
    //   await new Promise(r => setTimeout(() => r(), 1000))
    //   input.a += 1
    // }
  </script>
</head>

<body>
</body>